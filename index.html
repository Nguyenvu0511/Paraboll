<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng Parabol N√¢ng Cao üöÄ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f3f4f6;
            color: #111827;
            padding: 1rem;
        }
        canvas {
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid #d1d5db;
        }
        .controls {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 500px;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .control-grid {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 1rem;
        }
        /* S·ª≠ d·ª•ng media query cho m√†n h√¨nh l·ªõn h∆°n */
        @media (min-width: 640px) {
            .control-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.5rem;
            }
        }
        .control-item {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body class="bg-gray-100">

    <h1 class="text-2xl font-bold mb-4 text-gray-800">M√¥ Ph·ªèng Parabol N√¢ng Cao üí´</h1>

    <!-- Khung v·∫Ω (canvas) ƒë·ªÉ v·∫Ω Parabol -->
    <canvas id="parabolaCanvas" width="500" height="500"></canvas>

    <!-- Khu v·ª±c ƒëi·ªÅu khi·ªÉn -->
    <div class="controls">
        <div class="control-grid">
            
            <!-- ƒêi·ªÅu khi·ªÉn a -->
            <div class="control-item">
                <label for="aSlider" class="block mb-1 font-medium text-gray-700">H·ªá s·ªë $a$ (ƒë·ªô m·ªü)</label>
                <input type="range" id="aSlider" min="0.05" max="1" step="0.01" value="0.1">
                <span class="mt-1 text-sm text-center font-mono" id="aValue">a = 0.10</span>
            </div>

            <!-- ƒêi·ªÅu khi·ªÉn h -->
            <div class="control-item">
                <label for="hSlider" class="block mb-1 font-medium text-gray-700">ƒê·ªânh $h$ (ho√†nh ƒë·ªô)</label>
                <input type="range" id="hSlider" min="-10" max="10" step="0.1" value="0">
                <span class="mt-1 text-sm text-center font-mono" id="hValue">h = 0.0</span>
            </div>

            <!-- ƒêi·ªÅu khi·ªÉn k -->
            <div class="control-item">
                <label for="kSlider" class="block mb-1 font-medium text-gray-700">ƒê·ªânh $k$ (tung ƒë·ªô)</label>
                <input type="range" id="kSlider" min="-10" max="10" step="0.1" value="0">
                <span class="mt-1 text-sm text-center font-mono" id="kValue">k = 0.0</span>
            </div>

            <!-- ƒêi·ªÅu khi·ªÉn g√≥c -->
            <div class="control-item">
                <label for="angleSlider" class="block mb-1 font-medium text-gray-700">G√≥c xoay (ƒë·ªô)</label>
                <input type="range" id="angleSlider" min="-180" max="180" step="1" value="0">
                <span class="mt-1 text-sm text-center font-mono" id="angleValue">g√≥c = 0¬∞</span>
            </div>

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('parabolaCanvas');
            const ctx = canvas.getContext('2d');

            // L·∫•y t·∫•t c·∫£ c√°c thanh tr∆∞·ª£t v√† nh√£n
            const aSlider = document.getElementById('aSlider');
            const hSlider = document.getElementById('hSlider');
            const kSlider = document.getElementById('kSlider');
            const angleSlider = document.getElementById('angleSlider');
            
            const aValueSpan = document.getElementById('aValue');
            const hValueSpan = document.getElementById('hValue');
            const kValueSpan = document.getElementById('kValue');
            const angleValueSpan = document.getElementById('angleValue');

            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // ƒê·∫∑t g·ªëc t·ªça ƒë·ªô (0,0) c·ªßa logic v√†o CH√çNH GI·ªÆA canvas
            const originX = canvasWidth / 2;
            const originY = canvasHeight / 2;

            // T·ª∑ l·ªá: 1 ƒë∆°n v·ªã to√°n h·ªçc = 20 pixels
            const scale = 20;
            
            // H·∫±ng s·ªë easing cho animation m∆∞·ª£t
            const easing = 0.08;

            // Tr·∫°ng th√°i (state) c·ªßa Parabol
            // 'current' l√† gi√° tr·ªã ƒëang ƒë∆∞·ª£c v·∫Ω
            // 'target' l√† gi√° tr·ªã m√† slider mu·ªën
            const state = {
                current: {
                    a: parseFloat(aSlider.value),
                    h: parseFloat(hSlider.value),
                    k: parseFloat(kSlider.value),
                    angle: parseFloat(angleSlider.value)
                },
                target: {
                    a: parseFloat(aSlider.value),
                    h: parseFloat(hSlider.value),
                    k: parseFloat(kSlider.value),
                    angle: parseFloat(angleSlider.value)
                }
            };

            // C·∫≠p nh·∫≠t gi√° tr·ªã 'target' khi k√©o slider
            aSlider.addEventListener('input', e => state.target.a = parseFloat(e.target.value));
            hSlider.addEventListener('input', e => state.target.h = parseFloat(e.target.value));
            kSlider.addEventListener('input', e => state.target.k = parseFloat(e.target.value));
            angleSlider.addEventListener('input', e => state.target.angle = parseFloat(e.target.value));

            // H√†m v·∫Ω l∆∞·ªõi t·ªça ƒë·ªô
            function drawGrid() {
                ctx.strokeStyle = '#e5e7eb'; // M√†u l∆∞·ªõi (x√°m nh·∫°t)
                ctx.lineWidth = 1;
                ctx.font = '10px Inter';
                ctx.fillStyle = '#9ca3af';

                // V·∫Ω l∆∞·ªõi d·ªçc
                for (let x = -originX; x < canvasWidth; x += scale) {
                    ctx.beginPath();
                    ctx.moveTo(originX + x, 0);
                    ctx.lineTo(originX + x, canvasHeight);
                    ctx.stroke();
                    // Ghi s·ªë (ƒë∆°n v·ªã to√°n h·ªçc)
                    if (x !== 0 && Math.abs(x / scale) < 25) {
                         ctx.fillText(x / scale, originX + x + 2, originY - 2);
                    }
                }

                // V·∫Ω l∆∞·ªõi ngang
                for (let y = -originY; y < canvasHeight; y += scale) {
                    ctx.beginPath();
                    ctx.moveTo(0, originY + y);
                    ctx.lineTo(canvasWidth, originY + y);
                    ctx.stroke();
                     // Ghi s·ªë (ƒë∆°n v·ªã to√°n h·ªçc)
                    if (y !== 0 && Math.abs(y / scale) < 25) {
                        ctx.fillText(-y / scale, originX + 2, originY + y - 2); // (y √¢m v√¨ tr·ª•c y ng∆∞·ª£c)
                    }
                }

                // V·∫Ω tr·ª•c ch√≠nh (X, Y)
                ctx.strokeStyle = '#9ca3af'; // M√†u tr·ª•c (x√°m ƒë·∫≠m)
                ctx.lineWidth = 2;
                
                // Tr·ª•c Y
                ctx.beginPath();
                ctx.moveTo(originX, 0);
                ctx.lineTo(originX, canvasHeight);
                ctx.stroke();

                // Tr·ª•c X
                ctx.beginPath();
                ctx.moveTo(0, originY);
                ctx.lineTo(canvasWidth, originY);
                ctx.stroke();
                
                // G·ªëc O
                ctx.fillStyle = '#111827';
                ctx.fillText('O(0, 0)', originX + 2, originY - 2);
            }

            // H√†m v·∫Ω Parabol
            function drawParabola(a, h, k, angle) {
                // Chuy·ªÉn ƒë·ªïi ƒë·ªânh (h, k) t·ª´ t·ªça ƒë·ªô to√°n h·ªçc sang t·ªça ƒë·ªô canvas
                const vertexCanvasX = originX + h * scale;
                const vertexCanvasY = originY - k * scale; // Tr·ª´ v√¨ tr·ª•c Y canvas ng∆∞·ª£c
                
                ctx.save(); // L∆∞u l·∫°i tr·∫°ng th√°i canvas (tr∆∞·ªõc khi xoay/di chuy·ªÉn)
                
                // 1. Di chuy·ªÉn canvas ƒë·∫øn ƒë·ªânh (h, k)
                ctx.translate(vertexCanvasX, vertexCanvasY);
                
                // 2. Xoay canvas quanh ƒëi·ªÉm m·ªõi n√†y
                // (Chuy·ªÉn ƒë·ªô sang radian v√† d√πng d·∫•u √¢m ƒë·ªÉ xoay ng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì)
                ctx.rotate(-angle * Math.PI / 180);

                // --- B√¢y gi·ªù, ch√∫ng ta v·∫Ω Parabol y = ax^2 ƒë∆°n gi·∫£n ---
                // --- ngay t·∫°i g·ªëc t·ªça ƒë·ªô (0,0) M·ªöI c·ªßa canvas ---
                
                ctx.strokeStyle = '#3b82f6'; // M√†u xanh d∆∞∆°ng
                ctx.lineWidth = 2.5;
                ctx.beginPath();

                // V·∫Ω t·ª´ -25 ƒë·∫øn +25 (ƒë∆°n v·ªã to√°n h·ªçc)
                const range = 25;
                for (let x_math = -range; x_math <= range; x_math += 0.1) {
                    let y_math = a * x_math * x_math;

                    // Chuy·ªÉn (x_math, y_math) sang pixel (scaled)
                    let x_pixel = x_math * scale;
                    let y_pixel = -y_math * scale; // √Çm v√¨ tr·ª•c Y

                    if (x_math === -range) {
                        ctx.moveTo(x_pixel, y_pixel);
                    } else {
                        ctx.lineTo(x_pixel, y_pixel);
                    }
                }
                ctx.stroke();

                // V·∫Ω ch·∫•m ƒë·ªè ·ªü ƒë·ªânh
                ctx.fillStyle = '#ef4444'; // M√†u ƒë·ªè
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, 2 * Math.PI); // (0,0) trong h·ªá t·ªça ƒë·ªô ƒë√£ di chuy·ªÉn
                ctx.fill();

                ctx.restore(); // Ph·ª•c h·ªìi l·∫°i tr·∫°ng th√°i canvas (v·ªÅ nh∆∞ c≈©)
            }

            // V√≤ng l·∫∑p Animation
            function animate() {
                // 1. C·∫≠p nh·∫≠t gi√° tr·ªã 'current' ti·∫øn g·∫ßn ƒë·∫øn 'target'
                // ƒê√¢y ch√≠nh l√† ph√©p "N·ªôi suy tuy·∫øn t√≠nh" (Lerp) t·∫°o ra s·ª± m∆∞·ª£t m√†
                state.current.a += (state.target.a - state.current.a) * easing;
                state.current.h += (state.target.h - state.current.h) * easing;
                state.current.k += (state.target.k - state.current.k) * easing;
                state.current.angle += (state.target.angle - state.current.angle) * easing;

                // 2. X√≥a to√†n b·ªô canvas
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                // 3. V·∫Ω l·∫°i l∆∞·ªõi
                drawGrid();

                // 4. V·∫Ω l·∫°i Parabol v·ªõi gi√° tr·ªã 'current' ƒë√£ ƒë∆∞·ª£c l√†m m∆∞·ª£t
                drawParabola(
                    state.current.a,
                    state.current.h,
                    state.current.k,
                    state.current.angle
                );

                // 5. C·∫≠p nh·∫≠t text hi·ªÉn th·ªã
                aValueSpan.textContent = `a = ${state.current.a.toFixed(2)}`;
                hValueSpan.textContent = `h = ${state.current.h.toFixed(1)}`;
                kValueSpan.textContent = `k = ${state.current.k.toFixed(1)}`;
                angleValueSpan.textContent = `g√≥c = ${state.current.angle.toFixed(0)}¬∞`;

                // 6. Y√™u c·∫ßu tr√¨nh duy·ªát v·∫Ω khung h√¨nh ti·∫øp theo
                requestAnimationFrame(animate);
            }

            // B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p animation!
            animate();
        });
    </script>

</body>
</html>

